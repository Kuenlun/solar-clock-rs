name: Rust

on:
  push:
    branches: ["master"]
  pull_request:
    branches: ["master"]

permissions:
  contents: read
  pull-requests: write

env:
  CARGO_TERM_COLOR: always

jobs:
  license-check:
    name: Check License Headers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check Rust license headers
        shell: bash
        run: |
          set -euo pipefail
          LICENSE_FILE=".github/license_header.rs"
          MISSING=0
          while IFS= read -r file; do
            if ! head -n "$(wc -l < "$LICENSE_FILE")" "$file" | diff -u "$LICENSE_FILE" - > /dev/null; then
              echo "‚ùå Missing or incorrect license in: $file"
              MISSING=1
            fi
          done < <(find src/ -name "*.rs")
          if [ $MISSING -eq 1 ]; then
            echo "Some files are missing the correct license header."
            exit 1
          else
            echo "‚úÖ All files have the correct license header."
          fi

  build-and-test:
    name: Build and Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - uses: actions/checkout@v4
      - uses: swatinem/rust-cache@v2

      - name: Build
        run: cargo build --all-features --workspace

      - name: Test
        run: cargo test --all-features --workspace

  coverage:
    name: Coverage
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - uses: swatinem/rust-cache@v2
      - uses: taiki-e/install-action@cargo-llvm-cov

      - name: Measure coverage
        shell: bash
        id: coverage_step
        run: |
          # --- CONFIGURATION ---
          OUTPUT_FILE="coverage.raw"
          JSON_FILE="coverage.json"
          COMMENT_FILE="coverage.txt"

          # Initialize default statuses (Assuming worst case or skipped)
          STATUS_BUILD="‚ùå"
          STATUS_TEST="‚õî" # Defaults to skipped/blocked
          STATUS_COV="‚õî"  # Defaults to skipped/blocked

          # --- EXECUTION ---
          # We disable 'exit on error' (set +e) to handle the failure manually
          set +e

          # Run cargo llvm-cov with JSON output for reliable parsing.
          # We redirect stderr to stdout (2>&1) to capture compiler errors in the same file.
          cargo llvm-cov --all-features --workspace --color never --json > "$JSON_FILE" 2>&1
          EXIT_CODE=$?

          # Also capture human-readable output for logs (only if successful)
          # Note: Running llvm-cov twice is intentional - we need both structured JSON for parsing
          # and human-readable text for displaying in the collapsible log section.
          if [ $EXIT_CODE -eq 0 ]; then
            cargo llvm-cov --all-features --workspace --color never > "$OUTPUT_FILE" 2>&1 || true
          else
            # If JSON generation failed, capture the error output
            cp "$JSON_FILE" "$OUTPUT_FILE"
          fi

          # Re-enable 'exit on error'
          set -e

          # --- LOGIC ANALYSIS ---

          # Extract JSON data once for reuse throughout the script
          # cargo-llvm-cov outputs info messages followed by a single JSON line
          # We use grep to find and extract the line containing the JSON object
          JSON_DATA=$(grep -o '^{.*}$' "$JSON_FILE" 2>/dev/null || echo "")

          # Scenario 1: Everything passed
          if [ $EXIT_CODE -eq 0 ]; then
            STATUS_BUILD="‚úÖ"
            STATUS_TEST="‚úÖ"
            STATUS_COV="‚úÖ" # Will display info icon or percentage later
          else
            # Scenario 2: Failure occurred. Was it Build or Tests?
            # Check if we extracted valid JSON (indicates compilation succeeded)
            if [ -n "$JSON_DATA" ] && echo "$JSON_DATA" | jq -e '.type == "llvm.coverage.json.export"' >/dev/null 2>&1; then
              STATUS_BUILD="‚úÖ"
              STATUS_TEST="‚ùå"
              STATUS_COV="‚õî" # Coverage is irrelevant if tests fail
            else
              # Scenario 3: Compilation failed (no valid JSON output)
              STATUS_BUILD="‚ùå"
              STATUS_TEST="‚õî"
              STATUS_COV="‚õî"
            fi
          fi

          # --- REPORT GENERATION ---

          echo "### ü¶Ä Rust CI Report" > "$COMMENT_FILE"

          # 1. Summary Table
          echo "| Category | Status | Details |" >> "$COMMENT_FILE"
          echo "|:---|:---:|:---|" >> "$COMMENT_FILE"

          # Build Row
          if [ "$STATUS_BUILD" = "‚úÖ" ]; then
             echo "| **Compilation** | ‚úÖ | Success |" >> "$COMMENT_FILE"
          else
             echo "| **Compilation** | ‚ùå | **Failed** |" >> "$COMMENT_FILE"
          fi

          # Test Row
          if [ "$STATUS_TEST" = "‚úÖ" ]; then
             echo "| **Tests** | ‚úÖ | All tests passed |" >> "$COMMENT_FILE"
          elif [ "$STATUS_TEST" = "‚ùå" ]; then
             echo "| **Tests** | ‚ùå | **Some tests failed** |" >> "$COMMENT_FILE"
          else
             echo "| **Tests** | ‚õî | Skipped (Build failed) |" >> "$COMMENT_FILE"
          fi

          # Coverage Row (Summary)
          if [ "$STATUS_COV" = "‚úÖ" ]; then
             # Extract total coverage percentage from JSON using jq (more reliable than awk)
             COV_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.lines.percent' 2>/dev/null || echo "N/A")
             if [ "$COV_PERCENT" != "N/A" ]; then
               # Format as percentage
               COV_PERCENT="${COV_PERCENT}%"
             fi
             echo "| **Coverage** | ‚ÑπÔ∏è | **$COV_PERCENT** |" >> "$COMMENT_FILE"
          else
             echo "| **Coverage** | ‚õî | Skipped |" >> "$COMMENT_FILE"
          fi

          echo "" >> "$COMMENT_FILE"

          # 2. Detailed Coverage Table (ONLY if everything passed)
          if [ "$STATUS_COV" = "‚úÖ" ]; then
            echo "#### üìä Coverage Breakdown" >> "$COMMENT_FILE"
            echo "| Type | Total | Missed | Coverage |" >> "$COMMENT_FILE"
            echo "|:---|:---:|:---:|:---:|" >> "$COMMENT_FILE"
            
            # Use jq to parse JSON and extract coverage metrics reliably
            REGIONS_TOTAL=$(echo "$JSON_DATA" | jq -r '.data[0].totals.regions.count')
            REGIONS_MISSED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.regions.notcovered')
            REGIONS_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.regions.percent')
            
            FUNCTIONS_TOTAL=$(echo "$JSON_DATA" | jq -r '.data[0].totals.functions.count')
            FUNCTIONS_COVERED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.functions.covered')
            # Use jq for arithmetic to ensure correct handling of integer vs float values
            FUNCTIONS_MISSED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.functions.count - .data[0].totals.functions.covered')
            FUNCTIONS_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.functions.percent')
            
            LINES_TOTAL=$(echo "$JSON_DATA" | jq -r '.data[0].totals.lines.count')
            LINES_COVERED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.lines.covered')
            # Use jq for arithmetic to ensure correct handling of integer vs float values
            LINES_MISSED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.lines.count - .data[0].totals.lines.covered')
            LINES_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.lines.percent')
            
            BRANCHES_TOTAL=$(echo "$JSON_DATA" | jq -r '.data[0].totals.branches.count')
            BRANCHES_MISSED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.branches.notcovered')
            BRANCHES_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.branches.percent')
            
            echo "| Regions | $REGIONS_TOTAL | $REGIONS_MISSED | ${REGIONS_PERCENT}% |" >> "$COMMENT_FILE"
            echo "| Functions | $FUNCTIONS_TOTAL | $FUNCTIONS_MISSED | ${FUNCTIONS_PERCENT}% |" >> "$COMMENT_FILE"
            echo "| Lines | $LINES_TOTAL | $LINES_MISSED | ${LINES_PERCENT}% |" >> "$COMMENT_FILE"
            echo "| Branches | $BRANCHES_TOTAL | $BRANCHES_MISSED | ${BRANCHES_PERCENT}% |" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
          fi

          # 3. Logs (Collapsible)
          echo "<details>" >> "$COMMENT_FILE"

          if [ $EXIT_CODE -eq 0 ]; then
            echo "<summary>üü¢ <strong>Click to view Test Logs</strong></summary>" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
            echo '```text' >> "$COMMENT_FILE"
            # Clean up the log for success (remove file table to keep it short)
            # If the expected 'Filename' header exists, strip from there; otherwise, fall back to last 100 lines
            if grep -q '^Filename' "$OUTPUT_FILE"; then
              sed '/^Filename/,$d' "$OUTPUT_FILE" >> "$COMMENT_FILE"
            else
              tail -n 100 "$OUTPUT_FILE" >> "$COMMENT_FILE"
            fi
          else
            echo "<summary>üî¥ <strong>Click to view Failure Logs</strong></summary>" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
            echo '```text' >> "$COMMENT_FILE"
            # Show the last 100 lines so the error is likely visible at the bottom
            tail -n 100 "$OUTPUT_FILE" >> "$COMMENT_FILE"
          fi

          echo '```' >> "$COMMENT_FILE"
          echo "</details>" >> "$COMMENT_FILE"

          # --- EXIT HANDLING ---
          # We saved the exit code earlier. Now we write it to a file to check it in the next step.
          # We DO NOT exit here, because we want the "Comment coverage" step to run even if tests failed.
          echo "$EXIT_CODE" > exit_code.txt

      - name: Comment coverage
        if: github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: code-coverage
          path: coverage.txt

      - name: Check Run Status
        shell: bash
        run: |
          if [ ! -f exit_code.txt ]; then
            echo "Error: exit_code.txt not found"
            exit 1
          fi
          if [ ! -s exit_code.txt ]; then
            echo "Error: exit_code.txt is empty"
            exit 1
          fi
          EXIT_CODE=$(cat exit_code.txt)
          if ! [[ "$EXIT_CODE" =~ ^[0-9]+$ ]]; then
            echo "Error: Invalid exit code - must be a valid integer"
            exit 1
          fi
          if [ "$EXIT_CODE" -gt 255 ]; then
            echo "Error: Exit code out of range - must be between 0 and 255"
            exit 1
          fi
          if [ "$EXIT_CODE" -ne 0 ]; then
            echo "Workflow failed with exit code $EXIT_CODE"
            exit $EXIT_CODE
          fi

  # This job acts as a "final gate" for branch protection rules.
  # It will only run if all required jobs complete successfully.
  # In GitHub, you configure this job ("All Checks Passed") as the only required status check.
  all-checks-passed:
    name: All Checks Passed
    runs-on: ubuntu-latest
    needs: [build-and-test, coverage, license-check]
    steps:
      - run: echo "All jobs passed successfully!"
