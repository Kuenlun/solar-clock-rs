name: Rust

on:
  push:
    branches: ["master"]
  pull_request:
    branches: ["master"]

permissions:
  contents: read
  pull-requests: write

env:
  CARGO_TERM_COLOR: always

jobs:
  coverage:
    name: Coverage on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - uses: actions/checkout@v4
      - uses: swatinem/rust-cache@v2
      - uses: taiki-e/install-action@cargo-llvm-cov

      - name: Measure coverage
        shell: bash
        id: coverage_step
        run: |
          # --- CONFIGURATION ---
          OUTPUT_FILE="coverage.raw"
          COMMENT_FILE="coverage.txt"

          # Initialize default statuses (Assuming worst case or skipped)
          STATUS_BUILD="âŒ"
          STATUS_TEST="â›”" # Defaults to skipped/blocked
          STATUS_COV="â›”"  # Defaults to skipped/blocked

          # --- EXECUTION ---
          # We disable 'exit on error' (set +e) to handle the failure manually
          set +e

          # Run cargo llvm-cov. 
          # We redirect stderr to stdout (2>&1) to capture compiler errors in the same file.
          cargo llvm-cov --all-features --workspace --color never > "$OUTPUT_FILE" 2>&1
          EXIT_CODE=$?

          # Re-enable 'exit on error'
          set -e

          # --- LOGIC ANALYSIS ---

          # Scenario 1: Everything passed
          if [ $EXIT_CODE -eq 0 ]; then
            STATUS_BUILD="âœ…"
            STATUS_TEST="âœ…"
            STATUS_COV="âœ…" # Will display info icon or percentage later
          else
            # Scenario 2: Failure occurred. Was it Build or Tests?
            # If the output contains "test result:", it means compilation finished and tests ran (but failed).
            if grep -q "test result:" "$OUTPUT_FILE"; then
              STATUS_BUILD="âœ…"
              STATUS_TEST="âŒ"
              STATUS_COV="â›”" # Coverage is irrelevant if tests fail
            else
              # Scenario 3: Compilation failed (no test result line found)
              STATUS_BUILD="âŒ"
              STATUS_TEST="â›”"
              STATUS_COV="â›”"
            fi
          fi

          # --- REPORT GENERATION ---

          echo "### ðŸ¦€ Rust CI Report" > "$COMMENT_FILE"

          # 1. Summary Table
          echo "| Category | Status | Details |" >> "$COMMENT_FILE"
          echo "|:---|:---:|:---|" >> "$COMMENT_FILE"

          # Build Row
          if [ "$STATUS_BUILD" == "âœ…" ]; then
             echo "| **Compilation** | âœ… | Success |" >> "$COMMENT_FILE"
          else
             echo "| **Compilation** | âŒ | **Failed** |" >> "$COMMENT_FILE"
          fi

          # Test Row
          if [ "$STATUS_TEST" == "âœ…" ]; then
             echo "| **Tests** | âœ… | All tests passed |" >> "$COMMENT_FILE"
          elif [ "$STATUS_TEST" == "âŒ" ]; then
             echo "| **Tests** | âŒ | **Some tests failed** |" >> "$COMMENT_FILE"
          else
             echo "| **Tests** | â›” | Skipped (Build failed) |" >> "$COMMENT_FILE"
          fi

          # Coverage Row (Summary)
          if [ "$STATUS_COV" == "âœ…" ]; then
             # Extract total line coverage percentage (Column 10 is usually Line Coverage, $NF is Branch Coverage)
             COV_PERCENT=$(grep "^TOTAL" "$OUTPUT_FILE" | awk '{print $10}' || echo "N/A")
             echo "| **Coverage** | â„¹ï¸ | **$COV_PERCENT** |" >> "$COMMENT_FILE"
          else
             echo "| **Coverage** | â›” | Skipped |" >> "$COMMENT_FILE"
          fi

          echo "" >> "$COMMENT_FILE"

          # 2. Detailed Coverage Table (ONLY if everything passed)
          if [ "$STATUS_COV" == "âœ…" ]; then
            echo "#### ðŸ“Š Coverage Breakdown" >> "$COMMENT_FILE"
            echo "| Type | Total | Missed | Coverage |" >> "$COMMENT_FILE"
            echo "|:---|:---:|:---:|:---:|" >> "$COMMENT_FILE"
            grep "^TOTAL" "$OUTPUT_FILE" | awk '{ printf "| Regions | %s | %s | %s |\n| Functions | %s | %s | %s |\n| Lines | %s | %s | %s |\n| Branches | %s | %s | %s |\n", $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13 }' >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
          fi

          # 3. Logs (Collapsible)
          echo "<details>" >> "$COMMENT_FILE"

          if [ $EXIT_CODE -eq 0 ]; then
            echo "<summary>ðŸŸ¢ <strong>Click to view Test Logs</strong></summary>" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
            echo '```text' >> "$COMMENT_FILE"
            # Clean up the log for success (remove file table to keep it short)
            sed '/^Filename/,$d' "$OUTPUT_FILE" >> "$COMMENT_FILE"
          else
            echo "<summary>ðŸ”´ <strong>Click to view Failure Logs</strong></summary>" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
            echo '```text' >> "$COMMENT_FILE"
            # Show the last 100 lines so the error is likely visible at the bottom
            tail -n 100 "$OUTPUT_FILE" >> "$COMMENT_FILE"
          fi

          echo '```' >> "$COMMENT_FILE"
          echo "</details>" >> "$COMMENT_FILE"

          # --- EXIT HANDLING ---
          # We saved the exit code earlier. Now we write it to a file to check it in the next step.
          # We DO NOT exit here, because we want the "Comment coverage" step to run even if tests failed.
          echo "$EXIT_CODE" > exit_code.txt

      - name: Comment coverage
        if: matrix.os == 'ubuntu-latest' && github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: code-coverage
          path: coverage.txt

      - name: Check Run Status
        shell: bash
        run: |
          EXIT_CODE=$(cat exit_code.txt)
          if [ "$EXIT_CODE" -ne 0 ]; then
            echo "Workflow failed with exit code $EXIT_CODE"
            exit $EXIT_CODE
          fi

  # This job acts as a "final gate" for branch protection rules.
  # It will only run if the 'coverage' job (and its entire matrix) completes successfully.
  # In GitHub, you configure this job ("All Checks Passed") as the only required status check.
  all-checks-passed:
    name: All Checks Passed
    runs-on: ubuntu-latest
    needs: [coverage]
    steps:
      - run: echo "All jobs passed successfully!"
