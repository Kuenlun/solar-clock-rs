name: Rust

on:
  push:
    branches: ["master"]
  pull_request:
    branches: ["master"]

permissions:
  contents: read

env:
  CARGO_TERM_COLOR: always

jobs:
  license-check:
    name: Check License Headers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check Rust license headers
        shell: bash
        run: |
          set -euo pipefail
          LICENSE_FILE=".github/license_header.rs"
          MISSING=0
          while IFS= read -r file; do
            if ! head -n "$(wc -l < "$LICENSE_FILE")" "$file" | diff -u "$LICENSE_FILE" - > /dev/null; then
              echo "‚ùå Missing or incorrect license in: $file"
              MISSING=1
            fi
          done < <(find src/ -name "*.rs")
          if [ $MISSING -eq 1 ]; then
            echo "Some files are missing the correct license header."
            exit 1
          else
            echo "‚úÖ All files have the correct license header."
          fi

  fmt:
    name: Rustfmt
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check Formatting
        run: cargo fmt --all -- --check

  build-and-test:
    name: Build and Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - uses: actions/checkout@v4
      - uses: swatinem/rust-cache@v2

      - name: Build
        run: cargo build --all-features --workspace

      - name: Test
        run: cargo test --all-features --workspace

  coverage:
    name: Coverage
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - uses: actions/checkout@v4
      - uses: swatinem/rust-cache@v2
      - uses: taiki-e/install-action@cargo-llvm-cov

      - name: Measure coverage
        shell: bash
        run: |
          # --- CONFIGURATION ---
          LOG_FILE="coverage.log"
          JSON_FILE="coverage.json"
          COMMENT_FILE="coverage.txt"

          # Initialize default statuses
          STATUS_BUILD="‚ùå"
          STATUS_TEST="‚õî" 
          STATUS_COV="‚õî"

          # --- EXECUTION ---
          set +e

          # 1. Capture logs (Human readable output)
          # We run this first to capture build/test failures in readable format
          echo "Running coverage tests..."
          cargo llvm-cov --all-features --workspace --color never > "$LOG_FILE" 2>&1
          EXIT_CODE=$?

          # 2. Generate JSON (Data for parsing)
          # Only if previous step succeeded (or even if it failed, we might want partial data, 
          # but usually JSON generation fails if build fails).
          # We run it again specifically for JSON output to ensure no log pollution in the file.
          if [ $EXIT_CODE -eq 0 ]; then
            cargo llvm-cov --all-features --workspace --json --output-path "$JSON_FILE"
          else
            echo "{}" > "$JSON_FILE"
          fi

          set -e

          # --- LOGIC ANALYSIS ---

          # Read JSON file content directly
          JSON_DATA=$(cat "$JSON_FILE")

          # Scenario 1: Everything passed
          if [ $EXIT_CODE -eq 0 ]; then
            STATUS_BUILD="‚úÖ"
            STATUS_TEST="‚úÖ"
            STATUS_COV="‚úÖ" 
          else
            # Scenario 2: Failure occurred. Check logs for hints
            if grep -q "Compiling" "$LOG_FILE" && ! grep -q "error\[E" "$LOG_FILE"; then
               # Build likely passed if we got to running tests
               STATUS_BUILD="‚úÖ"
               STATUS_TEST="‚ùå"
            else
               STATUS_BUILD="‚ùå"
               STATUS_TEST="‚õî"
            fi
            STATUS_COV="‚õî"
          fi

          # --- REPORT GENERATION ---

          echo "### ü¶Ä Rust CI Report" > "$COMMENT_FILE"

          # 1. Summary Table
          echo "| Category | Status | Details |" >> "$COMMENT_FILE"
          echo "|:---|:---:|:---|" >> "$COMMENT_FILE"

          # Build Row
          if [ "$STATUS_BUILD" = "‚úÖ" ]; then
             echo "| **Compilation** | ‚úÖ | Success |" >> "$COMMENT_FILE"
          else
             echo "| **Compilation** | ‚ùå | **Failed** |" >> "$COMMENT_FILE"
          fi

          # Test Row
          if [ "$STATUS_TEST" = "‚úÖ" ]; then
             echo "| **Tests** | ‚úÖ | All tests passed |" >> "$COMMENT_FILE"
          elif [ "$STATUS_TEST" = "‚ùå" ]; then
             echo "| **Tests** | ‚ùå | **Some tests failed** |" >> "$COMMENT_FILE"
          else
             echo "| **Tests** | ‚õî | Skipped (Build failed) |" >> "$COMMENT_FILE"
          fi

          # Coverage Row (Summary)
          if [ "$STATUS_COV" = "‚úÖ" ]; then
             # Extract total coverage percentage directly from JSON
             COV_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.lines.percent // 0' 2>/dev/null || echo "N/A")
             if [ "$COV_PERCENT" != "N/A" ]; then
               # Format as percentage with 2 decimal places
               COV_PERCENT=$(printf "%.2f%%" "$COV_PERCENT")
             fi
             echo "| **Coverage** | ‚ÑπÔ∏è | **$COV_PERCENT** |" >> "$COMMENT_FILE"
          else
             echo "| **Coverage** | ‚õî | Skipped |" >> "$COMMENT_FILE"
          fi

          echo "" >> "$COMMENT_FILE"

          # 2. Detailed Coverage Table (ONLY if everything passed)
          if [ "$STATUS_COV" = "‚úÖ" ] && echo "$JSON_DATA" | jq -e '.data[0].totals' >/dev/null 2>&1; then
            echo "#### üìä Coverage Breakdown" >> "$COMMENT_FILE"
            echo "| Type | Total | Missed | Coverage |" >> "$COMMENT_FILE"
            echo "|:---|:---:|:---:|:---:|" >> "$COMMENT_FILE"
            
            # Use jq to parse JSON and extract coverage metrics reliably
            REGIONS_TOTAL=$(echo "$JSON_DATA" | jq -r '.data[0].totals.regions.count // 0')
            REGIONS_MISSED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.regions.notcovered // 0')
            REGIONS_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.regions.percent // 0')
            REGIONS_PERCENT=$(printf "%.2f%%" "$REGIONS_PERCENT")
            
            FUNCTIONS_TOTAL=$(echo "$JSON_DATA" | jq -r '.data[0].totals.functions.count // 0')
            FUNCTIONS_COVERED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.functions.covered // 0')
            FUNCTIONS_MISSED=$(echo "$JSON_DATA" | jq -r '(.data[0].totals.functions.count // 0) - (.data[0].totals.functions.covered // 0)')
            FUNCTIONS_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.functions.percent // 0')
            FUNCTIONS_PERCENT=$(printf "%.2f%%" "$FUNCTIONS_PERCENT")
            
            LINES_TOTAL=$(echo "$JSON_DATA" | jq -r '.data[0].totals.lines.count // 0')
            LINES_COVERED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.lines.covered // 0')
            LINES_MISSED=$(echo "$JSON_DATA" | jq -r '(.data[0].totals.lines.count // 0) - (.data[0].totals.lines.covered // 0)')
            LINES_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.lines.percent // 0')
            LINES_PERCENT=$(printf "%.2f%%" "$LINES_PERCENT")
            
            BRANCHES_TOTAL=$(echo "$JSON_DATA" | jq -r '.data[0].totals.branches.count // 0')
            BRANCHES_MISSED=$(echo "$JSON_DATA" | jq -r '.data[0].totals.branches.notcovered // 0')
            BRANCHES_PERCENT=$(echo "$JSON_DATA" | jq -r '.data[0].totals.branches.percent // 0')
            BRANCHES_PERCENT=$(printf "%.2f%%" "$BRANCHES_PERCENT")
            
            echo "| Regions | $REGIONS_TOTAL | $REGIONS_MISSED | $REGIONS_PERCENT |" >> "$COMMENT_FILE"
            echo "| Functions | $FUNCTIONS_TOTAL | $FUNCTIONS_MISSED | $FUNCTIONS_PERCENT |" >> "$COMMENT_FILE"
            echo "| Lines | $LINES_TOTAL | $LINES_MISSED | $LINES_PERCENT |" >> "$COMMENT_FILE"
            echo "| Branches | $BRANCHES_TOTAL | $BRANCHES_MISSED | $BRANCHES_PERCENT |" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
          fi

          # 3. Logs (Collapsible)
          echo "<details>" >> "$COMMENT_FILE"

          if [ $EXIT_CODE -eq 0 ]; then
            echo "<summary>üü¢ <strong>Click to view Test Logs</strong></summary>" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
            echo '```text' >> "$COMMENT_FILE"
            # Clean up the log for success - try to find the summary table
            if grep -q '^Filename' "$LOG_FILE"; then
              sed -n '/^Filename/,$p' "$LOG_FILE" >> "$COMMENT_FILE"
            else
              tail -n 100 "$LOG_FILE" >> "$COMMENT_FILE"
            fi
          else
            echo "<summary>üî¥ <strong>Click to view Failure Logs</strong></summary>" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
            echo '```text' >> "$COMMENT_FILE"
            tail -n 100 "$LOG_FILE" >> "$COMMENT_FILE"
          fi

          echo '```' >> "$COMMENT_FILE"
          echo "</details>" >> "$COMMENT_FILE"

          # --- EXIT HANDLING ---
          echo "$EXIT_CODE" > exit_code.txt

      - name: Comment coverage
        if: github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: code-coverage
          path: coverage.txt

      - name: Check Run Status
        shell: bash
        run: |
          if [ ! -f exit_code.txt ]; then
            echo "Error: exit_code.txt not found"
            exit 1
          fi
          if [ ! -s exit_code.txt ]; then
            echo "Error: exit_code.txt is empty"
            exit 1
          fi
          EXIT_CODE=$(tr -d '[:space:]' < exit_code.txt)
          if ! [[ "$EXIT_CODE" =~ ^[0-9]+$ ]]; then
            echo "Error: Invalid exit code - must be a valid integer"
            exit 1
          fi
          if [ "$EXIT_CODE" -ne 0 ]; then
            echo "Workflow failed with exit code $EXIT_CODE"
            exit $EXIT_CODE
          fi

  # This job acts as a "final gate" for branch protection rules.
  # It will only run if all required jobs complete successfully.
  # In GitHub, you configure this job ("All Checks Passed") as the only required status check.
  all-checks-passed:
    name: All Checks Passed
    runs-on: ubuntu-latest
    needs: [build-and-test, coverage, license-check, fmt]
    steps:
      - run: echo "All jobs passed successfully!"
