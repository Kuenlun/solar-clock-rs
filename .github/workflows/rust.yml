name: Rust

on:
  push:
    branches: ["master"]
  pull_request:
    branches: ["master"]

permissions:
  contents: read
  pull-requests: write

env:
  CARGO_TERM_COLOR: always

jobs:
  license-check:
    name: Check License Headers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check Rust license headers
        shell: bash
        run: |
          set -euo pipefail
          LICENSE_FILE=".github/license_header.rs"
          MISSING=0
          while IFS= read -r file; do
            if ! head -n "$(wc -l < "$LICENSE_FILE")" "$file" | diff -u "$LICENSE_FILE" -; then
              echo "âŒ Missing or incorrect license in: $file"
              MISSING=1
            fi
          done < <(find src/ -name "*.rs")
          if [ $MISSING -eq 1 ]; then
            echo "Some files are missing the correct license header."
            exit 1
          else
            echo "âœ… All files have the correct license header."
          fi

  build-and-test:
    name: Build and Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - uses: actions/checkout@v4
      - uses: swatinem/rust-cache@v2

      - name: Build
        run: cargo build --all-features --workspace

      - name: Test
        run: cargo test --all-features --workspace

  coverage:
    name: Coverage
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - uses: swatinem/rust-cache@v2
      - uses: taiki-e/install-action@cargo-llvm-cov

      - name: Measure coverage
        shell: bash
        id: coverage_step
        run: |
          # --- CONFIGURATION ---
          OUTPUT_FILE="coverage.raw"
          COMMENT_FILE="coverage.txt"

          # Initialize default statuses (Assuming worst case or skipped)
          STATUS_BUILD="âŒ"
          STATUS_TEST="â›”" # Defaults to skipped/blocked
          STATUS_COV="â›”"  # Defaults to skipped/blocked

          # --- EXECUTION ---
          # We disable 'exit on error' (set +e) to handle the failure manually
          set +e

          # Run cargo llvm-cov. 
          # We redirect stderr to stdout (2>&1) to capture compiler errors in the same file.
          cargo llvm-cov --all-features --workspace --color never > "$OUTPUT_FILE" 2>&1
          EXIT_CODE=$?

          # Re-enable 'exit on error'
          set -e

          # --- LOGIC ANALYSIS ---

          # Scenario 1: Everything passed
          if [ $EXIT_CODE -eq 0 ]; then
            STATUS_BUILD="âœ…"
            STATUS_TEST="âœ…"
            STATUS_COV="âœ…" # Will display info icon or percentage later
          else
            # Scenario 2: A failure occurred (build or tests).
            # We rely solely on the exit code and do not parse textual output,
            # to avoid fragile heuristics that depend on cargo's output format.
            STATUS_BUILD="âŒ"
            STATUS_TEST="âŒ"
            STATUS_COV="â›”" # Coverage is irrelevant if build or tests fail
          fi

          # --- REPORT GENERATION ---

          echo "### ðŸ¦€ Rust CI Report" > "$COMMENT_FILE"

          # 1. Summary Table
          echo "| Category | Status | Details |" >> "$COMMENT_FILE"
          echo "|:---|:---:|:---|" >> "$COMMENT_FILE"

          # Build Row
          if [ "$STATUS_BUILD" = "âœ…" ]; then
             echo "| **Compilation** | âœ… | Success |" >> "$COMMENT_FILE"
          else
             echo "| **Compilation** | âŒ | **Failed** |" >> "$COMMENT_FILE"
          fi

          # Test Row
          if [ "$STATUS_TEST" = "âœ…" ]; then
             echo "| **Tests** | âœ… | All tests passed |" >> "$COMMENT_FILE"
          elif [ "$STATUS_TEST" = "âŒ" ]; then
             echo "| **Tests** | âŒ | **Some tests failed** |" >> "$COMMENT_FILE"
          else
             echo "| **Tests** | â›” | Skipped (Build failed) |" >> "$COMMENT_FILE"
          fi

          # Coverage Row (Summary)
          if [ "$STATUS_COV" = "âœ…" ]; then
             # Extract total coverage percentage by matching percentage-like fields instead of relying on a fixed column
             COV_PERCENT=$(grep "^TOTAL" "$OUTPUT_FILE" | awk '{ for (i = 1; i <= NF; i++) if ($i ~ /^[0-9.]+%$/) last = $i; } END { if (last != "") print last; }' || echo "N/A")
             echo "| **Coverage** | â„¹ï¸ | **$COV_PERCENT** |" >> "$COMMENT_FILE"
          else
             echo "| **Coverage** | â›” | Skipped |" >> "$COMMENT_FILE"
          fi

          echo "" >> "$COMMENT_FILE"

          # 2. Detailed Coverage Table (ONLY if everything passed)
          if [ "$STATUS_COV" = "âœ…" ]; then
            echo "#### ðŸ“Š Coverage Breakdown" >> "$COMMENT_FILE"
            echo "| Type | Total | Missed | Coverage |" >> "$COMMENT_FILE"
            echo "|:---|:---:|:---:|:---:|" >> "$COMMENT_FILE"
            COV_TABLE=$(awk '
              /^TOTAL/ {
                # Find sequences like: <total> <missed> <percent%>
                for (i = 1; i <= NF - 2; i++) {
                  if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^[0-9]+$/ && $(i+2) ~ /^[0-9.]+%$/) {
                    triplet_idx++;
                    total[triplet_idx]  = $i;
                    missed[triplet_idx] = $(i+1);
                    cov[triplet_idx]    = $(i+2);
                    i += 2;
                  }
                }
              }
              END {
                # Only print rows if we found at least one triplet; expect up to 4 (Regions, Functions, Lines, Branches)
                if (triplet_idx >= 1) {
                  printf "| Regions | %s | %s | %s |\n",   total[1], missed[1], cov[1];
                }
                if (triplet_idx >= 2) {
                  printf "| Functions | %s | %s | %s |\n", total[2], missed[2], cov[2];
                }
                if (triplet_idx >= 3) {
                  printf "| Lines | %s | %s | %s |\n",     total[3], missed[3], cov[3];
                }
                if (triplet_idx >= 4) {
                  printf "| Branches | %s | %s | %s |\n",  total[4], missed[4], cov[4];
                }
              }' "$OUTPUT_FILE")
            if [ -n "$COV_TABLE" ]; then
              printf "%s\n" "$COV_TABLE" >> "$COMMENT_FILE"
            else
              echo "| _Coverage details unavailable: unexpected TOTAL line format_ |" >> "$COMMENT_FILE"
            fi
            echo "" >> "$COMMENT_FILE"
          fi

          # 3. Logs (Collapsible)
          echo "<details>" >> "$COMMENT_FILE"

          if [ $EXIT_CODE -eq 0 ]; then
            echo "<summary>ðŸŸ¢ <strong>Click to view Test Logs</strong></summary>" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
            echo '```text' >> "$COMMENT_FILE"
            # Clean up the log for success (remove file table to keep it short)
            # If the expected 'Filename' header exists, strip from there; otherwise, fall back to last 100 lines
            if grep -q '^Filename' "$OUTPUT_FILE"; then
              sed '/^Filename/,$d' "$OUTPUT_FILE" >> "$COMMENT_FILE"
            else
              tail -n 100 "$OUTPUT_FILE" >> "$COMMENT_FILE"
            fi
          else
            echo "<summary>ðŸ”´ <strong>Click to view Failure Logs</strong></summary>" >> "$COMMENT_FILE"
            echo "" >> "$COMMENT_FILE"
            echo '```text' >> "$COMMENT_FILE"
            # Show the last 100 lines so the error is likely visible at the bottom
            tail -n 100 "$OUTPUT_FILE" >> "$COMMENT_FILE"
          fi

          echo '```' >> "$COMMENT_FILE"
          echo "</details>" >> "$COMMENT_FILE"

          # --- EXIT HANDLING ---
          # We saved the exit code earlier. Now we write it to a file to check it in the next step.
          # We DO NOT exit here, because we want the "Comment coverage" step to run even if tests failed.
          echo "$EXIT_CODE" > exit_code.txt

      - name: Comment coverage
        if: github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: code-coverage
          path: coverage.txt

      - name: Check Run Status
        shell: bash
        run: |
          if [ ! -f exit_code.txt ]; then
            echo "Error: exit_code.txt not found"
            exit 1
          fi
          if [ ! -s exit_code.txt ]; then
            echo "Error: exit_code.txt is empty"
            exit 1
          fi
          EXIT_CODE=$(cat exit_code.txt)
          if ! [[ "$EXIT_CODE" =~ ^[0-9]+$ ]]; then
            echo "Error: Invalid exit code - must be a valid integer"
            exit 1
          fi
          if [ "$EXIT_CODE" -gt 255 ]; then
            echo "Error: Exit code out of range - must be between 0 and 255"
            exit 1
          fi
          if [ "$EXIT_CODE" -ne 0 ]; then
            echo "Workflow failed with exit code $EXIT_CODE"
            exit $EXIT_CODE
          fi

  # This job acts as a "final gate" for branch protection rules.
  # It will only run if all required jobs complete successfully.
  # In GitHub, you configure this job ("All Checks Passed") as the only required status check.
  all-checks-passed:
    name: All Checks Passed
    runs-on: ubuntu-latest
    needs: [build-and-test, coverage, license-check]
    steps:
      - run: echo "All jobs passed successfully!"
